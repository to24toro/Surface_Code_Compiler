Metadata-Version: 2.4
Name: surface_code_routing
Version: 0.0.1
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Dynamic: license-file

# Surface Code Compiler #
A compiler for the surface code for benchmarking runtimes using Litinksy's "Game of Surface Codes" costing.

The compiler takes a width and height for the number of surface code elements and treats gates as a mutual exclusion over a subset of the elements. Routing is performed using a biased A* search while the construction of the surface code itself is a linear program that (up to the vaguaries of Python) should complete in Polynomial time in the size of the surface code, and in the number of gates.  

## Dependencies ##
Python >=3.10
Numpy

Optionally dependent on GridSynth


## Gridsynth Installation ##

Currently GridSynth is partially merged into Quipper, so it follows that if we can install quipper then GridSynth should work.

Quipper is currently in a Haskell dependency hell, newer versions of ghc will not compile it, and newer versions of Cabal are incompatible with various dependencies of Quipper (newer versions of the dependencies are in turn incompatible with versions of ghc that are compatible with Quipper). As a result ghc 8.6.5 is stable, though 8.8.4 may or may not also work.

We'll version quipper using ghcup, you may look into your own nix, cabal or stack based solutions to this problem. This currently works as Cabal will invoke the legacy v1 installation methods, this may be unstable in the future.

```
    curl https://gitlab.haskell.org/haskell/ghcup/raw/master/ghcup > /tmp/ghcup
    chmod +x /tmp/ghcup
    /tmp/ghcup install 8.6.5
    /tmp/ghcup set 8.6.5
    /tmp/ghcup install-cabal 2.4.1.0

    # Update path
    PATH="$HOME/.cabal/bin:$HOME/.ghcup/bin:$PATH"

    # Install Quipper
    cabal update
    cabal install quipper-all
```
You may wish to add the path command to your terminal's appropriate rc file. Rather than installing quipper you may also install newsynth independently.

For more details see the quipper docs: (https://www.mathstat.dal.ca/~selinger/quipper/README)[https://www.mathstat.dal.ca/~selinger/quipper/README]

Once that's installed we can compile the relevant Haskell files 
```
make all
```

Once this is done now we can install the package
```
python setup.py install
```


Surface Code Compiler - Complete Usage Guide

  Based on my examination of the repository, here's a comprehensive guide for using the Surface Code Compiler on macOS or Linux.

  Overview

  The Surface Code Compiler is a Python-based tool that compiles quantum circuits to the surface code architecture. It takes quantum gate sequences (DAGs) and compiles them
  onto a 2D surface code layout with specified dimensions, performing routing and resource estimation using Litinsky's "Game of Surface Codes" costing model.

  ---
  Repository Structure

  Surface_Code_Compiler/
  ├── src/surface_code_routing/     # Main Python package
  │   ├── dag.py                    # DAG representation
  │   ├── instructions.py           # Basic quantum gates
  │   ├── lib_instructions.py       # Higher-level gates (Toffoli, T_Factory)
  │   ├── synth_instructions.py     # Synthesized rotation gates (requires GridSynth)
  │   ├── compiled_qcb.py          # Main compilation function
  │   ├── gate_synthesis.py        # GridSynth interface
  │   └── gridsynth/
  │       └── gate_synth.hs        # Haskell source for gate synthesis
  ├── examples/                     # Example circuits
  │   ├── ghz.py                   # GHZ state preparation
  │   ├── simple_rot.py            # Arbitrary rotations
  │   ├── qft/                     # Quantum Fourier Transform
  │   ├── arithmetic/              # Arithmetic circuits
  │   └── ...
  └── tests/                       # Unit tests

  ---
  Installation

  1. Basic Installation (Required)

  Requirements:
  - Python ≥ 3.10
  - NumPy

  Install the package:

  cd Surface_Code_Compiler
  pip install -e .

  Or with pip3/python3 explicitly:
  python3 -m pip install -e .

  This installs the surface_code_routing package in editable mode.

  2. GridSynth Installation (Optional)

  GridSynth is ONLY required for:
  - Arbitrary rotation gates (Z_theta, CPHASE_theta)
  - Examples that use rotation synthesis

  GridSynth is NOT required for:
  - Basic gates: CNOT, Hadamard, X, Z, Phase, T
  - Clifford circuits
  - Most example circuits (GHZ, basic Toffoli chains, etc.)

  If you need GridSynth, follow the instructions in the README to install Quipper (which includes GridSynth). Then compile the Haskell executable:

  # After installing Quipper/GridSynth
  cd Surface_Code_Compiler
  make build

  This compiles src/surface_code_routing/gridsynth/gate_synth.

  ---
  Core Concepts

  1. DAG (Directed Acyclic Graph)

  Represents the quantum circuit as a sequence of gates with dependencies.

  2. QCB (Quantum Circuit Block)

  A 2D surface code layout with dimensions height × width where compilation occurs.

  3. Compilation

  Maps quantum gates onto the surface code, performs routing, and calculates resource costs.

  4. Key Parameters:

  - height, width: Dimensions of the surface code grid
  - precision: For gate synthesis (rotation approximation)
  - verbose: Enable compilation progress output

  ---
  Basic Usage Pattern

  All examples follow this pattern:

  from surface_code_routing.dag import DAG
  from surface_code_routing.instructions import CNOT, Hadamard, INIT
  from surface_code_routing.compiled_qcb import compile_qcb

  # 1. Create a DAG
  dag = DAG('MyCircuit')

  # 2. Add gates to the DAG
  dag.add_gate(Hadamard('q_0'))
  dag.add_gate(CNOT('q_0', 'q_1'))

  # 3. Compile to a surface code layout
  compiled = compile_qcb(dag, height=10, width=10)

  # 4. Extract results
  print(f'Cycles: {compiled.n_cycles()}')
  print(f'Space-time volume: {compiled.space_time_volume()}')

  ---
  Available Gates

  Basic Gates (No GridSynth needed)

  From surface_code_routing.instructions:
  - INIT(*qubits) - Initialize qubits
  - PREP(qubit) - Prepare qubit
  - MEAS(*qubits) - Measure qubits
  - CNOT(control, *targets) - Controlled-NOT
  - Hadamard(qubit) - Hadamard gate
  - X(qubit) - Pauli X
  - Z(qubit) - Pauli Z
  - Phase(qubit) - S gate (Phase gate)
  - RESET(qubit) - Reset
  - MOVE(source, dest) - Move operation
  - IDLE(qubit) - Idle/wait

  Library Gates

  From surface_code_routing.lib_instructions:
  - T(qubit) - T gate
  - T_Factory() - T-state factory (used as external resource)
  - Toffoli(ctrl1, ctrl2, target) - Toffoli gate

  Synthesis Gates (Require GridSynth)

  From surface_code_routing.synth_instructions:
  - Z_theta(p, q, precision=10) - Z rotation by π*p/q
  - CPHASE_theta(p, q, precision=10) - Controlled phase rotation

  ---
  Minimal Working Examples

  Example 1: GHZ State (No GridSynth)

  from surface_code_routing.dag import DAG
  from surface_code_routing.instructions import Hadamard, CNOT
  from surface_code_routing.compiled_qcb import compile_qcb

  def create_ghz(n_qubits, height, width):
      """Create an n-qubit GHZ state"""
      dag = DAG(f'GHZ{n_qubits}')

      # Apply Hadamard to first qubit
      dag.add_gate(Hadamard('q_0'))

      # Apply CNOTs to create entanglement
      for i in range(1, n_qubits):
          dag.add_gate(CNOT('q_0', f'q_{i}'))

      return compile_qcb(dag, height, width)

  # Run it
  if __name__ == '__main__':
      result = create_ghz(4, 10, 10)
      print(f'4-qubit GHZ on 10×10 grid:')
      print(f'  Cycles: {result.n_cycles()}')
      print(f'  Space-time volume: {result.space_time_volume()}')
      print(f'  Grid size: {result.width}×{result.height}')

  Run:
  python3 your_script.py

  Expected output:
  4-qubit GHZ on 10×10 grid:
    Cycles: 7
    Space-time volume: 84
    Grid size: 10×10

  Example 2: Using T-Factory

  from surface_code_routing.dag import DAG
  from surface_code_routing.instructions import INIT
  from surface_code_routing.lib_instructions import T, T_Factory
  from surface_code_routing.compiled_qcb import compile_qcb

  def circuit_with_t_gates(height, width):
      """Simple circuit with T gates"""
      dag = DAG('T_Circuit')

      dag.add_gate(INIT('q_0'))
      dag.add_gate(T('q_0'))
      dag.add_gate(T('q_0'))

      # Provide T_Factory as external resource
      return compile_qcb(dag, height, width, T_Factory())

  if __name__ == '__main__':
      result = circuit_with_t_gates(10, 10)
      print(f'Cycles: {result.n_cycles()}')
      print(f'Volume: {result.space_time_volume()}')

  Example 3: With Verbose Output

  from surface_code_routing.dag import DAG
  from surface_code_routing.instructions import Hadamard, CNOT
  from surface_code_routing.compiled_qcb import compile_qcb

  dag = DAG('Example')
  dag.add_gate(Hadamard('q_0'))
  dag.add_gate(CNOT('q_0', 'q_1'))

  # Enable verbose mode to see compilation steps
  result = compile_qcb(dag, 8, 8, verbose=True)

  Output shows:
  Compiling <Example>
        Constructing QCB...
        Allocating QCB...
        Constructing Mapping
        Routing...

  ---
  Running Existing Examples

  Run GHZ Example

  python3 -c "
  from examples.ghz import ghz
  result = ghz(4, 10, 10)
  print('Cycles:', result.n_cycles())
  print('Volume:', result.space_time_volume())
  "

  Run QFT Example (Requires GridSynth)

  # First ensure GridSynth is compiled
  make build

  # Then run
  cd examples/qft
  python3 qft.py

  Run Tests

  python3 -m pytest tests/
  # or
  python3 -m unittest discover tests/

  ---
  Compilation Outputs

  A CompiledQCB object has these key methods/attributes:

  | Method/Attribute    | Description                                   |
  |---------------------|-----------------------------------------------|
  | n_cycles()          | Number of surface code cycles                 |
  | space_time_volume() | Total resource cost (width × height × cycles) |
  | width               | QCB width                                     |
  | height              | QCB height                                    |
  | symbol              | Circuit identifier                            |
  | delays()            | Timing delays dictionary                      |
  | is_extern()         | Whether it's an external resource             |
  | is_factory()        | Whether it's a factory (no inputs)            |

  ---
  Common Issues & Solutions

  Issue 1: ModuleNotFoundError: No module named 'surface_code_routing'

  Solution: Install the package:
  pip install -e .

  Issue 2: FileNotFoundError: gate_synth

  Cause: You're using rotation gates without GridSynth compiled.

  Solutions:
  - Option A: Only use basic gates (no rotations)
  - Option B: Install Quipper/GridSynth and run make build

  Issue 3: AssertionError in router

  Cause: Circuit may be too complex for the given QCB size.

  Solution: Increase height and width parameters.

  ---
  Example Workflows

  Workflow 1: Quick Test (No GridSynth)

  git clone <repo>
  cd Surface_Code_Compiler
  pip install -e .

  python3 -c "
  from examples.ghz import ghz
  print('Cycles:', ghz(4, 10, 10).n_cycles())
  "

  Workflow 2: Full Setup (With GridSynth)

  # 1. Install Python package
  pip install -e .

  # 2. Install Quipper (see README for details)
  # ... follow Quipper installation ...

  # 3. Compile GridSynth
  make build

  # 4. Run examples with rotations
  python3 examples/qft/qft.py

  Workflow 3: Custom Circuit

  Create my_circuit.py:
  from surface_code_routing.dag import DAG
  from surface_code_routing.instructions import Hadamard, CNOT
  from surface_code_routing.compiled_qcb import compile_qcb

  dag = DAG('MyCircuit')
  dag.add_gate(Hadamard('q_0'))
  dag.add_gate(CNOT('q_0', 'q_1'))
  dag.add_gate(CNOT('q_1', 'q_2'))

  result = compile_qcb(dag, height=12, width=12, verbose=True)

  print(f'\n=== Results ===')
  print(f'Cycles: {result.n_cycles()}')
  print(f'Space-time volume: {result.space_time_volume()}')
  print(f'Grid: {result.width}×{result.height}')

  Run:
  python3 my_circuit.py

  ---
  Summary

  To get started immediately:

  1. Install: pip install -e .
  2. Test: Run a simple GHZ circuit (see Example 1)
  3. Explore: Check examples/ directory for more circuits

  GridSynth/Quipper is optional and only needed for arbitrary rotation gates. All basic quantum gates work without it.

  The compiler's main job is to:
  1. Take a quantum circuit (DAG of gates)
  2. Map it to a 2D surface code grid
  3. Route operations while respecting hardware constraints
  4. Output resource costs (cycles, space-time volume)

  This enables benchmarking and resource estimation for surface code implementations of quantum algorithms.
